<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artevo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#212529" />
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="1.png" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    

    <style>
        /* CSS Variables for Colors */
        :root {
            --bg-color: #f8f9fa;
            --container-bg: #fff;
            --text-color: #333;
            --header-color: #6f42c1;
            --border-color: #6f42c1;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-active-bg: #004085;
            --button-active-tool-bg: #28a745;
            --button-active-tool-hover-bg: #218838;
            --clear-button-bg: #dc3545;
            --save-button-bg: #6c757d;
            --undo-button-bg: #ffc107;
            --redo-button-bg: #17a2b8;
            --input-border: #ccc;
            --input-hover-border: #007bff;
            --input-focus-border: #6f42c1;
            --range-track-bg: #ddd;
            --canvas-bg: #fff; /* Canvas itself usually stays white for drawing */
            --grid-line-color: #e0e0e0;
            --stripe-color: rgba(224, 224, 224, 0.5); /* Light mode stripe color */
            --checker-color-1: rgba(240, 240, 240, 0.5); /* Light mode checker color 1 */
            --checker-color-2: rgba(200, 200, 200, 0.5); /* Light mode checker color 2 */
        }

        /* Dark Mode Specific Variables */
        body.dark-mode {
            --bg-color: #212529; /* Dark background */
            --container-bg: #343a40; /* Slightly lighter dark for container */
            --text-color: #e9ecef; /* Light text */
            --header-color: #9c7ee3; /* Lighter purple for header */
            --border-color: #9c7ee3; /* Lighter purple for border */
            --button-bg: #495057;
            --button-hover-bg: #6c757d;
            --button-active-bg: #868e96;
            --button-active-tool-bg: #20c997; /* Green for active tool in dark mode */
            --button-active-tool-hover-bg: #1bc88f;
            --clear-button-bg: #e0445d;
            --save-button-bg: #778899;
            --undo-button-bg: #ffda6a;
            --redo-button-bg: #41d2e0;
            --input-border: #495057;
            --input-hover-border: #41d2e0;
            --input-focus-border: #9c7ee3;
            --range-track-bg: #495057;
            --canvas-bg: #212529; /* Canvas background can be dark or remain white */
            --grid-line-color: #495057;
            --stripe-color: rgba(73, 80, 87, 0.5); /* Dark mode stripe color */
            --checker-color-1: rgba(52, 58, 64, 0.5); /* Dark mode checker color 1 */
            --checker-color-2: rgba(73, 80, 87, 0.5); /* Dark mode checker color 2 */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to give space for header */
            min-height: 100vh;
            margin: 0;
            padding: 10px; /* Reduced padding for mobile */
            box-sizing: border-box;
            
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            position: relative;
        }

        #darkModeToggle {
            position: absolute;
            top: 10px; /* Adjusted for mobile */
            right: 10px; /* Adjusted for mobile */
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px; /* Adjusted for mobile */
            cursor: pointer;
            font-size: 0.9em; /* Adjusted for mobile */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
            z-index: 1001;
        }

        #darkModeToggle:hover {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
        }

        #darkModeToggle:active {
            background-color: var(--button-active-bg);
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }


        h1 {
            color: var(--header-color);
            margin: 15px 0 20px; /* Adjusted margin for mobile */
            text-align: center;
            font-size: 2em; /* Default font size for H1 */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px; /* Adjusted padding for mobile */
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            max-width: 98vw; /* More responsive width */
            width: 850px; /* Max width for desktop */
            background-color: var(--container-bg);
            transition: background-color 0.3s ease;
            box-sizing: border-box;
        }
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px; /* Reduced gap for more elements on a line */
            margin-bottom: 15px; /* Reduced margin */
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        canvas {
            border: 2px solid var(--border-color);
            cursor: crosshair;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            background-color: var(--canvas-bg);
            transition: background-color 0.3s ease;
            max-width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            display: block;
            touch-action: none; /* Prevent browser touch actions like scrolling/zooming */
        }
        button {
            padding: 8px 12px; /* Slightly smaller padding */
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em; /* Slightly smaller font size */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
            white-space: nowrap;
            flex-shrink: 0; /* Prevent buttons from shrinking too much */
        }
        button:hover {
            background-color: var(--button-hover-bg);
        }
        button:active {
            background-color: var(--button-active-bg);
        }
        button.active {
            background-color: var(--button-active-tool-bg);
        }
        button.active:hover {
            background-color: var(--button-active-tool-hover-bg);
        }

        /* Specific button colors override general button styles */
        #clearCanvas { background-color: var(--clear-button-bg); }
        #clearCanvas:hover { background-color: color-mix(in srgb, var(--clear-button-bg) 85%, black); }
        #clearCanvas:active { background-color: color-mix(in srgb, var(--clear-button-bg) 70%, black); }

        #saveDrawing { background-color: var(--save-button-bg); }
        #saveDrawing:hover { background-color: color-mix(in srgb, var(--save-button-bg) 85%, black); }
        #saveDrawing:active { background-color: color-mix(in srgb, var(--save-button-bg) 70%, black); }

        #undoBtn { background-color: var(--undo-button-bg); }
        #undoBtn:hover { background-color: color-mix(in srgb, var(--undo-button-bg) 85%, black); }
        #undoBtn:active { background-color: color-mix(in srgb, var(--undo-button-bg) 70%, black); }

        #redoBtn { background-color: var(--redo-button-bg); }
        #redoBtn:hover { background-color: color-mix(in srgb, var(--redo-button-bg) 85%, black); }
        #redoBtn:active { background-color: color-mix(in srgb, var(--redo-button-bg) 70%, black); }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 35px; /* Smaller color picker */
            height: 35px;
            border: none;
            padding: 0;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
            transition: transform 0.1s, border-color 0.2s;
            border: 2px solid var(--input-border);
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid var(--input-border);
            border-radius: 4px;
        }
        input[type="color"]:hover {
            transform: scale(1.05);
        }

        input[type="range"] {
            width: 90px; /* Reduced width for range inputs */
            -webkit-appearance: none;
            height: 8px;
            background: var(--range-track-bg);
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-left: 5px;
            flex-grow: 1; /* Allow to grow in flex container */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--header-color);
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--header-color);
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .tool-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap; /* Allows inner elements to wrap */
            justify-content: center;
            width: 100%; /* Ensure groups take full width for proper wrapping */
        }
        .tool-group label {
            font-size: 0.85em; /* Smaller font size */
            color: var(--text-color);
            white-space: nowrap;
        }
        /* Specific adjustments for labels that might have auto margin */
        .tool-group label:not(.no-auto-margin) {
            margin-left: auto; /* Default for labels in groups unless overridden */
        }
        select {
            padding: 6px; /* Smaller padding */
            border-radius: 5px;
            border: 1px solid var(--input-border);
            background-color: var(--container-bg);
            color: var(--text-color);
            font-size: 0.85em; /* Smaller font size */
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.3s, color 0.3s;
            flex-shrink: 0;
            min-width: 80px; /* Ensure select is not too small */
        }
        select:hover {
            border-color: var(--input-hover-border);
        }
        select:focus {
            outline: none;
            border-color: var(--input-focus-border);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--input-focus-border) 30%, transparent);
        }

        /* Styling for the dynamically created text input */
        #textInputOverlay {
            position: absolute;
            border: 1px solid var(--border-color);
            padding: 8px; /* Slightly larger padding for better touch */
            font-family: inherit;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
            display: none;
            background: var(--container-bg);
            color: var(--text-color);
            font-size: 1em; /* Ensure text input is readable */
        }

        /* Brush Preview Styles */
        #brushPreview {
            width: 25px; /* Smaller preview */
            height: 25px;
            border-radius: 50%;
            background-color: black;
            border: 1px solid #777;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            margin-left: 8px; /* Adjusted margin */
            transition: all 0.1s ease-out;
            flex-shrink: 0;
        }

        /* Guided Drawing Options */
        #guidedOptions {
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
            padding: 10px;
            margin-top: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--container-bg);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            color: var(--text-color);
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        /* Challenge Container */
        #challengeContainer {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px 20px; /* Adjusted padding */
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            max-width: 90%;
            box-sizing: border-box;
        }
        #challengePromptDisplay {
            font-size: 1.3em; /* Slightly smaller for mobile */
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--header-color);
        }
        #challengeTimerDisplay {
            font-size: 1.8em; /* Slightly smaller for mobile */
            font-weight: bold;
            color: var(--text-color);
        }

        /* Canvas Size Controls */
        #canvasSizeControls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px; /* Reduced gap */
            margin-bottom: 10px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        #canvasSizeControls input[type="number"] {
            width: 70px; /* Compact width for numbers */
            padding: 7px;
            border-radius: 5px;
            border: 1px solid var(--input-border);
            background-color: var(--container-bg);
            color: var(--text-color);
            font-size: 0.85em;
            transition: border-color 0.2s;
        }
        #canvasSizeControls input[type="number"]:focus {
            outline: none;
            border-color: var(--input-focus-border);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--input-focus-border) 30%, transparent);
        }
        #canvasSizeControls label {
            font-size: 0.85em;
        }
        #applyCanvasSize {
            padding: 8px 12px;
            font-size: 0.85em;
        }

        /* Footer Styles */
        footer {
            margin-top: 30px;
            padding: 15px;
            font-size: 0.9em;
            color: var(--text-color);
            text-align: center;
            border-top: 1px solid var(--border-color);
            width: 100%;
            box-sizing: border-box;
            background-color: var(--container-bg);
            box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        footer a {
            color: var(--header-color);
            text-decoration: none;
            font-weight: bold;
            transition: color 0.2s ease;
        }
        footer a:hover {
            color: var(--button-hover-bg);
            text-decoration: underline;
        }


        /* Media Queries for Smaller Screens (General adjustments) */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            .container {
                padding: 15px;
                max-width: 100%;
            }
            .toolbar {
                gap: 6px; /* Slightly smaller gap on general mobile */
            }
            .tool-group {
                gap: 6px; /* Consistency */
            }
            button {
                padding: 7px 10px;
                font-size: 0.8em;
            }
            select, input[type="range"], input[type="number"] {
                font-size: 0.8em;
                padding: 6px;
            }
            input[type="range"] {
                width: 70px; /* Make range smaller */
            }
            #brushPreview {
                width: 20px;
                height: 20px;
                margin-left: 5px;
            }
            #canvasSizeControls {
                gap: 6px;
            }
            #canvasSizeControls input[type="number"] {
                flex-basis: auto; /* Revert to auto for better mobile handling */
                width: 80px; /* Specific width for number inputs */
            }
        }

        /* Media Queries for Even Smaller Screens (specifically for 3-4 items per line) */
        @media (max-width: 600px) {
            h1 {
                font-size: 1.6em;
            }
            .container {
                padding: 10px; /* Even less padding */
            }
            .toolbar {
                gap: 6px; /* Smallest gap */
            }

            .tool-group {
                flex: 1 1 100%; /* Ensure groups take full width */
                justify-content: center; /* Center items within the tool-group */
                gap: 6px; /* Gap within tool-group */
                margin-bottom: 5px; /* Reduce spacing between groups */
            }

            /* Generic sizing for buttons/selects/inputs to achieve 3-4 per line */
            .tool-group > button,
            .tool-group > select,
            .tool-group > input:not([type="color"]):not([type="range"]):not([type="file"]),
            #canvasSizeControls input[type="number"] {
                flex-basis: calc(33.33% - 6px); /* Aim for 3 items per row, considering gap */
                min-width: 80px; /* Minimum width to prevent them from becoming too small */
                font-size: 0.75em; /* Smaller font size */
                padding: 6px 8px; /* Smaller padding */
                box-sizing: border-box; /* Important for calc() */
            }
            
            /* Specific overrides for elements that need more or less space */
            .tool-group.primary-tools > button, /* Pen, Eraser, Fill, Text */
            .tool-group.primary-tools > select { /* Shape Tool */
                flex-basis: calc(25% - 6px); /* Aim for 4 items per row */
            }
            
            .tool-group.size-opacity > input[type="range"] {
                flex-basis: calc(50% - 6px); /* Range slider needs more space, 2 per row */
                width: auto; /* Override previous 100% if any */
            }
            .tool-group > input[type="color"] {
                width: 30px;
                height: 30px;
                flex-shrink: 0;
            }

            /* Specific overrides for labels and spans which are not interactive buttons/inputs */
            .tool-group label, .tool-group span:not(#brushSizeValue):not(#opacityValue):not(#guidedImageOpacityValue) {
                font-size: 0.75em; /* Smaller font for labels */
                white-space: nowrap;
                flex-shrink: 0;
            }
            /* Ensure labels directly before inputs don't have auto margin */
            .tool-group label:not(.no-auto-margin) {
                margin-left: 0; 
            }
            #brushPreview {
                width: 18px;
                height: 18px;
            }

            #applyCanvasSize {
                flex-basis: 100%; /* Full width for apply button */
            }
            #textInputOverlay {
                width: 90%; /* Text input adapts to screen width */
            }
        }
        
        @media (max-width: 400px) { /* Adjust for very narrow screens, prioritizing 2-3 items */
            .tool-group > button,
            .tool-group > select,
            .tool-group > input:not([type="color"]):not([type="range"]):not([type="file"]),
            #canvasSizeControls input[type="number"] {
                flex-basis: calc(50% - 6px); /* Aim for 2 items per row if very narrow */
                min-width: unset; /* Let flexbox decide */
            }

            .tool-group.primary-tools > button, /* Pen, Eraser, Fill, Text */
            .tool-group.primary-tools > select { /* Shape Tool */
                flex-basis: calc(50% - 6px); /* 2 per line on very small screens */
            }
        }
    </style>
</head>
<body>
    <button id="darkModeToggle">🌓 Dark Mode</button>

    <h1>Artevo</h1>
    <div class="container">
        <!-- Canvas Size Controls -->
        <div id="canvasSizeControls" class="tool-group">
            <label for="canvasWidth">Width:</label>
            <input type="number" id="canvasWidth" value="800" min="100" max="2000">
            <label for="canvasHeight">Height:</label>
            <input type="number" id="canvasHeight" value="600" min="100" max="2000">
            <button id="applyCanvasSize">Apply Size</button>
        </div>

        <div class="toolbar">
            <!-- Group 1: Primary Drawing Tools (Pen, Eraser, Shape, Fill, Text, Color) -->
            <div class="tool-group primary-tools">
                <button id="penTool" class="active">Pen (P)</button>
                <button id="eraserTool">Eraser (E)</button>
                <select id="shapeTool" title="Shapes">
                    <option value="line">Line</option>
                    <option value="rectangle">Rect (R)</option>
                    <option value="square">Square</option>
                    <option value="circle">Circle (C)</option>
                    <option value="ellipse">Ellipse</option>
                    <option value="triangle">Triangle (T)</option>
                    <option value="pentagon">Pentagon</option>
                    <option value="star">Star (S)</option>
                    <option value="hexagon">Hexagon (H)</option>
                    <option value="heptagon">Heptagon (7)</option>
                    <option value="octagon">Octagon (8)</option>
                    <option value="nonagon">Nonagon (9)</option>
                    <option value="decagon">Decagon (0)</option>
                    <option value="heart">Heart (Ctrl+H)</option>
                    <option value="arrow">Arrow (A)</option>
                    <option value="cloud">Cloud (L)</option>
                    <option value="lightning">Lightning (I)</option>
                    <option value="cross">Cross (X)</option>
                    <option value="diamond">Diamond (D)</option>
                    <option value="speechBubble">Speech (B)</option>
                    <option value="trapezoid">Trapezoid (Z)</option>
                </select>
                <button id="fillTool">Fill (F)</button>
                <button id="textTool">Text (T)</button>
                <label for="colorPicker" class="no-auto-margin">Color:</label>
                <input type="color" id="colorPicker" value="#000000">
            </div>

            <!-- Group 2: Size and Opacity -->
            <div class="tool-group size-opacity">
                <label for="brushSize" class="no-auto-margin">Size:</label>
                <input type="range" id="brushSize" min="1" max="50" value="5">
                <span id="brushSizeValue">5</span>px
                <div id="brushPreview"></div> <!-- Brush Preview Element -->
                <label for="opacitySlider" class="no-auto-margin">Opacity:</label>
                <input type="range" id="opacitySlider" min="0" max="100" value="100">
                <span id="opacityValue">100</span>%
            </div>

            <!-- New Grouping: Line Style, Fill Type, Background (3 items) -->
            <div class="tool-group">
                <label for="lineStyle" class="no-auto-margin">Line Style:</label>
                <select id="lineStyle">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                </select>
                <label for="fillType" class="no-auto-margin">Fill Type:</label>
                <select id="fillType">
                    <option value="solidColor">Solid Color</option>
                    <option value="linearGradient">Linear Gradient</option>
                </select>
                <label for="backgroundType" class="no-auto-margin">Background:</label>
                <select id="backgroundType">
                    <option value="solid">Solid</option>
                    <option value="grid">Grid</option>
                    <option value="dots">Dots</option>
                    <option value="stripes-h">H-Stripes</option>
                    <option value="stripes-v">V-Stripes</option>
                    <option value="checkerboard">Checkerboard</option>
                    <option value="image">Image</option>
                </select>
            </div>

            <!-- New Grouping: H-Sym, V-Sym, Set Image (3 items) -->
            <div class="tool-group">
                <button id="hSymmetryTool" title="Horizontal Symmetry">H-Sym</button>
                <button id="vSymmetryTool" title="Vertical Symmetry">V-Sym</button>
                <button id="setBackgroundImageBtn">Set Image</button>
                <input type="file" id="backgroundImageInput" accept="image/*" style="display: none;">
            </div>

            <!-- Original Group 5: Insert Image, Guided Drawing, Challenges -->
            <div class="tool-group">
                <button id="insertImageTool">Insert Image</button>
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button id="guidedDrawingBtn">Guided Drawing</button>
                <input type="file" id="guidedImageInput" accept="image/*" style="display: none;">
                <button id="startChallengeBtn">Drawing Challenge</button>
            </div>
            
            <!-- Group 6: Undo, Redo, Clear, Save Actions -->
            <div class="tool-group actions">
                <button id="undoBtn" style="background-color: var(--undo-button-bg);">Undo (Ctrl+Z)</button>
                <button id="redoBtn" style="background-color: var(--redo-button-bg);">Redo (Ctrl+Y)</button>
                <button id="clearCanvas" style="background-color: var(--clear-button-bg);">Clear (Delete)</button>
                <button id="saveDrawing" style="background-color: var(--save-button-bg);">Save Image</button>
            </div>
        </div>

        <!-- Guided Drawing Options -->
        <div id="guidedOptions" class="toolbar" style="display: none;">
            <label for="guidedImageOpacitySlider" class="no-auto-margin">Guide Opacity:</label>
            <input type="range" id="guidedImageOpacitySlider" min="0" max="100" value="50">
            <span id="guidedImageOpacityValue">50</span>%
            <button id="clearGuideBtn">Clear Guide</button>
        </div>

        <canvas id="drawingCanvas" width="800" height="600"></canvas>
    </div>
    <input type="text" id="textInputOverlay" placeholder="Type text here..." autofocus>

    <!-- Challenge Container -->
    <div id="challengeContainer">
        <div id="challengePromptDisplay"></div>
        <div id="challengeTimerDisplay">02:00</div>
    </div>

    <footer>
        Made with ❤️ by <a href="https://abdelrahmanz.netlify.app/" target="_blank">AbdElRahman</a>
    </footer>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        const penToolBtn = document.getElementById('penTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const insertImageToolBtn = document.getElementById('insertImageTool');
        const imageInput = document.getElementById('imageInput'); // For inserting an image as a drawable object
        const textToolBtn = document.getElementById('textTool');
        const textInputOverlay = document.getElementById('textInputOverlay');

        // Combined Shape Selector
        const shapeToolSelector = document.getElementById('shapeTool');

        const colorPicker = document.getElementById('colorPicker');
        const brushSizeSlider = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');
        const brushPreview = document.getElementById('brushPreview'); // New
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValueSpan = document.getElementById('opacityValue');
        const lineStyleSelector = document.getElementById('lineStyle');
        const fillTypeSelector = document.getElementById('fillType');

        const hSymmetryToolBtn = document.getElementById('hSymmetryTool');
        const vSymmetryToolBtn = document.getElementById('vSymmetryTool');

        const backgroundTypeSelector = document.getElementById('backgroundType'); // New
        const setBackgroundImageBtn = document.getElementById('setBackgroundImageBtn'); // New
        const backgroundImageInput = document.getElementById('backgroundImageInput'); // New

        const guidedDrawingBtn = document.getElementById('guidedDrawingBtn'); // New
        const guidedImageInput = document.getElementById('guidedImageInput'); // New
        const guidedOptions = document.getElementById('guidedOptions'); // New
        const guidedImageOpacitySlider = document.getElementById('guidedImageOpacitySlider'); // New
        const guidedImageOpacityValueSpan = document.getElementById('guidedImageOpacityValue'); // New
        const clearGuideBtn = document.getElementById('clearGuideBtn'); // New

        const startChallengeBtn = document.getElementById('startChallengeBtn'); // New
        const challengeContainer = document.getElementById('challengeContainer'); // New
        const challengePromptDisplay = document.getElementById('challengePromptDisplay'); // New
        const challengeTimerDisplay = document.getElementById('challengeTimerDisplay'); // New

        const canvasWidthInput = document.getElementById('canvasWidth'); // New
        const canvasHeightInput = document.getElementById('canvasHeight'); // New
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSize'); // New


        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const clearCanvasBtn = document.getElementById('clearCanvas');
        const saveDrawingBtn = document.getElementById('saveDrawing');

        const darkModeToggle = document.getElementById('darkModeToggle');

        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = colorPicker.value;
        let currentBrushSize = parseInt(brushSizeSlider.value);
        let currentOpacity = parseFloat(opacitySlider.value) / 100;
        let currentLineStyle = lineStyleSelector.value;
        let currentFillType = fillTypeSelector.value;
        let currentBackgroundType = backgroundTypeSelector.value; // New

        let hSymmetryEnabled = false;
        let vSymmetryEnabled = false;

        let startX, startY;
        let snapshot; // Used for shapes/images preview to store canvas state before a drag begins

        let loadedImage = null; // For drawable inserted images
        let loadedBackgroundImage = null; // New: For canvas background image
        let guidedImage = null; // New: For guided drawing trace-over image
        let guidedImageOpacity = parseFloat(guidedImageOpacitySlider.value) / 100; // New

        const history = [];
        let historyIndex = -1;

        // Challenge Variables
        const drawingPrompts = [
            "A cat playing with yarn",
            "A spaceship landing on a moon",
            "A whimsical treehouse",
            "A teacup with eyes",
            "A grumpy cloud",
            "A knight fighting a dragon",
            "A robot librarian",
            "An adventurous squirrel",
            "A magical key",
            "A floating island",
            "A city under the sea",
            "A talking flower",
            "An old wizard's hat",
            "A futuristic car",
            "A cozy reading nook",
            "A friendly monster",
            "A fantastical creature",
            "A hidden waterfall",
            "An abandoned castle",
            "A basket of fruit",
            "A happy sun",
            "A sleepy moon",
            "A tiny house on a giant mushroom",
            "A creature made of smoke",
            "A book that comes alive"
        ];
        let challengeInterval = null;
        let challengeTimeLeft = 0;

        // --- Canvas Initialization ---
        // ctx.lineCap and ctx.lineJoin are now applied in applyDrawingSettings()


        // --- History Management ---
        /**
         * Saves the current state of the canvas to the history array.
         * Clears any 'redo' states if new drawing occurs.
         * Also saves the current canvas state to local storage for persistence.
         */
        function saveState() {
            // console.log('Saving state. History length before splice:', history.length, 'historyIndex:', historyIndex);
            history.splice(historyIndex + 1); // Clear any redo states if new drawing begins
            const imageData = canvas.toDataURL(); // Capture current full canvas state
            history.push(imageData);
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
            // console.log('State saved. New history length:', history.length, 'new historyIndex:', historyIndex);
            saveToLocalStorage(); // Save to local storage after every state change
        }

        /**
         * Restores the canvas to a previous state from the history array.
         * This involves redrawing the background, then the historical image,
         * and then the guided image if present.
         */
        function restoreState() {
            // console.log('Restoring state. Current historyIndex:', historyIndex, 'History length:', history.length);
            // Always draw the base background first, clearing the canvas
            drawBackground(); 

            // If there's a historical state to load, draw it
            if (history.length > 0 && historyIndex >= 0) {
                const img = new Image();
                img.src = history[historyIndex];
                // Ensure the historical image is drawn *after* the background is set.
                img.onload = () => {
                    // console.log('Historical image loaded and drawn.');
                    ctx.drawImage(img, 0, 0);
                    // Draw guided image on top of the restored historical drawing
                    drawGuidedImage(); 
                };
                img.onerror = (e) => {
                    console.error('Error loading historical image from history:', e);
                    // Fallback: If historical image fails to load, at least show background and guided image.
                    drawGuidedImage();
                };
            } else {
                // If no history (e.g., cleared canvas or initial load), just draw background and guided image
                // console.log('No history to restore, drawing guided image only.');
                drawGuidedImage(); 
            }
            updateUndoRedoButtons();
        }

        /**
         * Saves the current canvas content to localStorage.
         */
        function saveToLocalStorage() {
            localStorage.setItem('drawingAppCanvas', canvas.toDataURL());
            localStorage.setItem('drawingAppCanvasWidth', canvas.width);
            localStorage.setItem('drawingAppCanvasHeight', canvas.height);
            // console.log('Canvas state saved to local storage.');
        }

        /**
         * Loads the canvas content from localStorage if available.
         * Returns true if data was loaded, false otherwise.
         */
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('drawingAppCanvas');
            const savedWidth = localStorage.getItem('drawingAppCanvasWidth');
            const savedHeight = localStorage.getItem('drawingAppCanvasHeight');

            if (savedData && savedWidth && savedHeight) {
                const img = new Image();
                img.src = savedData;
                img.onload = () => {
                    // console.log('Canvas state loaded from local storage.');
                    canvas.width = parseInt(savedWidth);
                    canvas.height = parseInt(savedHeight);
                    canvasWidthInput.value = canvas.width;
                    canvasHeightInput.value = canvas.height;

                    // After setting new dimensions, reapply drawing settings
                    applyDrawingSettings();

                    ctx.drawImage(img, 0, 0);
                    // After loading from storage, add this state to history
                    // Clear history first to prevent issues with partial loads or old sizes
                    history.length = 0;
                    historyIndex = -1;
                    saveState(); // Save the loaded state as the first history entry
                    drawGuidedImage(); // Redraw guided image on top
                };
                img.onerror = (e) => {
                    console.error('Error loading canvas state from local storage:', e);
                    // If loading fails, clear and start fresh
                    clearCanvasBtn.click();
                };
                return true;
            }
            return false;
        }

        /**
         * Updates the disabled state of the Undo and Redo buttons
         * based on the current position in the history.
         */
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // --- Tool Selection ---
        /**
         * Sets the currently active drawing tool and updates the UI accordingly.
         * @param {string} tool - The name of the tool to select (e.g., 'pen', 'rectangle').
         */
        function selectTool(tool) {
            currentTool = tool;
            textInputOverlay.style.display = 'none'; // Hide text input if switching tool

            // Remove 'active' class from all tool buttons
            document.querySelectorAll('.toolbar button').forEach(btn => {
                btn.classList.remove('active');
            });
            // Ensure shape selector is not 'active' if a non-shape tool is selected
            shapeToolSelector.classList.remove('active');


            // Add 'active' class to the selected tool's button or the shape selector
            const toolButtonMap = {
                'pen': penToolBtn,
                'eraser': eraserToolBtn,
                'fill': fillToolBtn,
                'image': insertImageToolBtn,
                'text': textToolBtn
            };
            if (toolButtonMap[tool]) {
                toolButtonMap[tool].classList.add('active');
            } else {
                // If it's a shape tool, activate the selector itself
                shapeToolSelector.classList.add('active');
                shapeToolSelector.value = tool; // Make sure the dropdown shows the selected shape
            }


            // Set appropriate cursor for the canvas
            if (['pen', 'line', 'rectangle', 'square', 'triangle', 'circle', 'ellipse', 'pentagon', 'star', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'heart', 'arrow', 'cloud', 'lightning', 'cross', 'diamond', 'speechBubble', 'trapezoid'].includes(tool)) {
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'eraser') {
                canvas.style.cursor = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'black\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'><path d=\'M21.17 4.17l-2.09 2.09c-.39.39-1.02.39-1.41 0l-2.09-2.09c-.39-.39-.39-1.02 0-1.41l2.09-2.09c.39-.39 1.02-.39 1.41 0l2.09 2.09c.39.39.39 1.02 0 1.41zM21 16l-3.23 3.23a2 2 0 01-2.83 0l-1.92-1.92a2 2 0 010-2.83L16 10zm-11 5L3 14l5-5 7 7-5 5z\'/></svg>"), auto';
            } else if (tool === 'fill') {
                canvas.style.cursor = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'black\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'><path d=\'M5 3l14 14M14 10l-4 4M21 21L3 3\'/><circle cx=\'12\' cy=\'12\' r=\'10\' fill=\'currentColor\' stroke=\'none\'/></svg>"), auto';
            } else if (tool === 'image') {
                canvas.style.cursor = 'grab';
            } else if (tool === 'text') {
                canvas.style.cursor = 'text';
            }
            updateBrushPreview(); // Update preview based on new tool (e.g., eraser color)
        }

        /**
         * Applies the current drawing settings (line width, opacity, line style, line caps/joins)
         * to the specified CanvasRenderingContext2D. This is crucial for drawing
         * consistently, especially after canvas resize (which resets context properties).
         * @param {CanvasRenderingContext2D} ctxToApply - The context to apply settings to. Defaults to main ctx.
         */
        function applyDrawingSettings(ctxToApply = ctx) {
            ctxToApply.lineWidth = currentBrushSize;
            ctxToApply.globalAlpha = currentOpacity;
            ctxToApply.lineCap = 'round'; // Ensure line caps are always round
            ctxToApply.lineJoin = 'round'; // Ensure line joins are always round

            if (currentLineStyle === 'solid') {
                ctxToApply.setLineDash([]);
            } else if (currentLineStyle === 'dashed') {
                ctxToApply.setLineDash([10, 5]);
            } else if (currentLineStyle === 'dotted') {
                ctxToApply.setLineDash([1, 2]);
            }
        }

        /**
         * Updates the visual appearance of the brush preview element
         * to reflect the current brush size, color, and opacity.
         */
        function updateBrushPreview() {
            const size = Math.min(currentBrushSize * 2, 30); // Scale preview size, max 30px
            brushPreview.style.width = `${size}px`;
            brushPreview.style.height = `${size}px`;
            brushPreview.style.backgroundColor = currentColor;
            brushPreview.style.opacity = currentOpacity;
            brushPreview.style.borderRadius = '50%'; // Always round for brush preview
            if (currentTool === 'eraser') {
                 brushPreview.style.backgroundColor = getComputedStyle(canvas).backgroundColor;
            }
        }

        // --- Background Drawing Helper Functions ---
        function drawHorizontalStripes(ctxToUse) {
            const stripeHeight = 20;
            // Get CSS variable for dynamic color
            const alternateColor = getComputedStyle(document.body).getPropertyValue('--stripe-color').trim();
            ctxToUse.globalAlpha = 1; // Stripes are opaque

            for (let y = 0; y < canvas.height; y += stripeHeight * 2) {
                ctxToUse.fillStyle = alternateColor;
                ctxToUse.fillRect(0, y, canvas.width, stripeHeight);
            }
        }

        function drawVerticalStripes(ctxToUse) {
            const stripeWidth = 20;
            // Get CSS variable for dynamic color
            const alternateColor = getComputedStyle(document.body).getPropertyValue('--stripe-color').trim();
            ctxToUse.globalAlpha = 1; // Stripes are opaque

            for (let x = 0; x < canvas.width; x += stripeWidth * 2) {
                ctxToUse.fillStyle = alternateColor;
                ctxToUse.fillRect(x, 0, stripeWidth, canvas.height);
            }
        }

        function drawCheckerboard(ctxToUse) {
            const squareSize = 40;
            // Get CSS variables for dynamic colors
            const color1 = getComputedStyle(document.body).getPropertyValue('--checker-color-1').trim();
            const color2 = getComputedStyle(document.body).getPropertyValue('--checker-color-2').trim();
            ctxToUse.globalAlpha = 1; // Checkerboard is opaque

            for (let y = 0; y < canvas.height; y += squareSize) {
                for (let x = 0; x < canvas.width; x += squareSize) {
                    const isEvenRow = (Math.floor(y / squareSize)) % 2 === 0;
                    const isEvenCol = (Math.floor(x / squareSize)) % 2 === 0;
                    ctxToUse.fillStyle = (isEvenRow && isEvenCol) || (!isEvenRow && !isEvenCol) ? color1 : color2;
                    ctxToUse.fillRect(x, y, squareSize, squareSize);
                }
            }
        }

        /**
         * Draws the selected background type (solid, grid, dots, stripes, checkerboard, or image)
         * onto the canvas. This is typically called before drawing historical states.
         */
        function drawBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear everything first
            // Get current computed background color from CSS
            const baseBgColor = getComputedStyle(canvas).backgroundColor;

            ctx.fillStyle = baseBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill with current base color

            if (currentBackgroundType === 'grid') {
                const gridSize = 20; // Size of each grid square
                const gridColor = getComputedStyle(document.body).getPropertyValue('--grid-line-color').trim();
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 1; // Grid lines are opaque

                for (let x = 0; x <= canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y <= canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            } else if (currentBackgroundType === 'dots') {
                const dotSize = 2; // Radius of each dot
                const dotSpacing = 20; // Spacing between dot centers
                const dotColor = getComputedStyle(document.body).getPropertyValue('--grid-line-color').trim();
                ctx.fillStyle = dotColor;
                ctx.globalAlpha = 1; // Dots are opaque

                for (let x = dotSpacing / 2; x <= canvas.width; x += dotSpacing) {
                    for (let y = dotSpacing / 2; y <= canvas.height; y += dotSpacing) {
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (currentBackgroundType === 'stripes-h') {
                drawHorizontalStripes(ctx);
            } else if (currentBackgroundType === 'stripes-v') {
                drawVerticalStripes(ctx);
            } else if (currentBackgroundType === 'checkerboard') {
                drawCheckerboard(ctx);
            } else if (currentBackgroundType === 'image' && loadedBackgroundImage) {
                // Draw background image scaled to fit/fill canvas
                ctx.globalAlpha = 1;
                const hRatio = canvas.width / loadedBackgroundImage.width;
                const vRatio = canvas.height / loadedBackgroundImage.height;
                const ratio = Math.max(hRatio, vRatio); // Use Math.max to cover the canvas
                const sWidth = loadedBackgroundImage.width;
                const sHeight = loadedBackgroundImage.height;
                const dWidth = sWidth * ratio;
                const dHeight = sHeight * ratio;
                const dx = (canvas.width - dWidth) / 2;
                const dy = (canvas.height - dHeight) / 2;

                ctx.drawImage(loadedBackgroundImage, 0, 0, sWidth, sHeight, dx, dy, dWidth, dHeight);
            }
            // Reset alpha to current drawing opacity after background is drawn
            ctx.globalAlpha = currentOpacity;
            applyDrawingSettings(); // Reapply drawing settings
        }

        /**
         * Draws the guided tracing image onto the canvas with its current opacity.
         * This image is not part of the drawing history.
         */
        function drawGuidedImage() {
            if (guidedImage) {
                ctx.save(); // Save current context state
                ctx.globalAlpha = guidedImageOpacity; // Apply guided image opacity

                // Scale image to fit canvas while maintaining aspect ratio, centered
                const imgAspectRatio = guidedImage.width / guidedImage.height;
                const canvasAspectRatio = canvas.width / canvas.height;
                let drawWidth, drawHeight, drawX, drawY;

                if (imgAspectRatio > canvasAspectRatio) { // Image is wider relative to canvas
                    drawWidth = canvas.width;
                    drawHeight = canvas.width / imgAspectRatio;
                    drawX = 0;
                    drawY = (canvas.height - drawHeight) / 2;
                } else { // Image is taller or same aspect ratio relative to canvas
                    drawHeight = canvas.height;
                    drawWidth = canvas.height * imgAspectRatio;
                    drawX = (canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                ctx.drawImage(guidedImage, drawX, drawY, drawWidth, drawHeight);
                ctx.restore(); // Restore context to previous state (e.g., globalAlpha for drawing)
            }
        }

        // --- Helper functions for drawing various shapes ---
        /**
         * Draws a regular polygon with a given number of sides.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} centerX - The x-coordinate of the center.
         * @param {number} centerY - The y-coordinate of the center.
         * @param {number} radius - The distance from the center to any vertex.
         * @param {number} sides - The number of sides of the polygon.
         */
        function drawRegularPolygon(ctxToUse, centerX, centerY, radius, sides) {
            ctxToUse.moveTo(centerX + radius * Math.cos(-Math.PI / 2), centerY + radius * Math.sin(-Math.PI / 2)); // Start at top for upright
            for (let i = 1; i <= sides; i++) {
                const angle = i * 2 * Math.PI / sides;
                ctxToUse.lineTo(centerX + radius * Math.cos(angle - Math.PI / 2), centerY + radius * Math.sin(angle - Math.PI / 2));
            }
            ctxToUse.closePath();
        }

        /**
         * Draws a 5-pointed star.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} centerX - The x-coordinate of the center.
         * @param {number} centerY - The y-coordinate of the center.
         * @param {number} outerRadius - The radius of the outer points.
         * @param {number} innerRadius - The radius of the inner points.
         * @param {number} points - The number of points (typically 5 for a star).
         */
        function drawStar(ctxToUse, centerX, centerY, outerRadius, innerRadius, points) {
            ctxToUse.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const radius = (i % 2 === 0) ? outerRadius : innerRadius;
                const angle = Math.PI / points * i;
                const x = centerX + radius * Math.cos(angle - Math.PI / 2); // Adjust angle for upright star
                const y = centerY + radius * Math.sin(angle - Math.PI / 2);
                if (i === 0) {
                    ctxToUse.moveTo(x, y);
                } else {
                    ctxToUse.lineTo(x, y);
                }
            }
            ctxToUse.closePath();
        }

        /**
         * Draws a heart shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} centerX - The x-coordinate of the center.
         * @param {number} centerY - The y-coordinate of the center.
         * @param {number} size - The overall size of the heart.
         */
        function drawHeart(ctxToUse, centerX, centerY, size) {
            ctxToUse.beginPath();
            ctxToUse.moveTo(centerX, centerY + size / 4);
            ctxToUse.bezierCurveTo(
                centerX + size / 2, centerY - size / 2,
                centerX + size, centerY,
                centerX, centerY + size
            );
            ctxToUse.bezierCurveTo(
                centerX - size, centerY,
                centerX - size / 2, centerY - size / 2,
                centerX, centerY + size / 4
            );
            ctxToUse.closePath();
        }

        /**
         * Draws an arrow shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} sx - Starting x-coordinate.
         * @param {number} sy - Starting y-coordinate.
         * @param {number} ex - Ending x-coordinate.
         * @param {number} ey - Ending y-coordinate.
         */
        function drawArrow(ctxToUse, sx, sy, ex, ey) {
            const headLength = 15; // length of head in pixels
            const angle = Math.atan2(ey - sy, ex - sx);
            ctxToUse.beginPath();
            ctxToUse.moveTo(sx, sy);
            ctxToUse.lineTo(ex, ey);
            ctxToUse.lineTo(ex - headLength * Math.cos(angle - Math.PI / 6), ey - headLength * Math.sin(angle - Math.PI / 6));
            ctxToUse.moveTo(ex, ey);
            ctxToUse.lineTo(ex - headLength * Math.cos(angle + Math.PI / 6), ey - headLength * Math.sin(angle + Math.PI / 6));
        }

        /**
         * Draws a cloud shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} centerX - The x-coordinate of the center.
         * @param {number} centerY - The y-coordinate of the center.
         * @param {number} size - The overall size of the cloud.
         */
        function drawCloud(ctxToUse, centerX, centerY, size) {
            ctxToUse.beginPath();
            ctxToUse.arc(centerX - size * 0.4, centerY, size * 0.4, 0, Math.PI * 2);
            ctxToUse.arc(centerX + size * 0.4, centerY, size * 0.4, 0, Math.PI * 2);
            ctxToUse.arc(centerX, centerY - size * 0.3, size * 0.3, 0, Math.PI * 2);
            ctxToUse.arc(centerX - size * 0.2, centerY + size * 0.2, size * 0.3, 0, Math.PI * 2);
            ctxToUse.arc(centerX + size * 0.2, centerY + size * 0.2, size * 0.3, 0, Math.PI * 2);
            ctxToUse.closePath();
        }

        /**
         * Draws a lightning bolt shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} sx - Starting x-coordinate.
         * @param {number} sy - Starting y-coordinate.
         * @param {number} ex - Ending x-coordinate.
         * @param {number} ey - Ending y-coordinate.
         */
        function drawLightning(ctxToUse, sx, sy, ex, ey) {
            ctxToUse.beginPath();
            const midX = sx + (ex - sx) / 2;
            const midY = sy + (ey - sy) / 2;
            ctxToUse.moveTo(sx, sy);
            ctxToUse.lineTo(midX + (ey - sy) * 0.1, midY - (ex - sx) * 0.1);
            ctxToUse.lineTo(midX - (ey - sy) * 0.1, midY + (ex - sx) * 0.1);
            ctxToUse.lineTo(ex, ey);
        }

        /**
         * Draws a cross shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} centerX - The x-coordinate of the center.
         * @param {number} centerY - The y-coordinate of the center.
         * @param {number} size - The overall size of the cross.
         */
        function drawCross(ctxToUse, centerX, centerY, size) {
            const armWidth = size / 3;
            const armHeight = size;
            ctxToUse.beginPath();
            // Vertical arm
            ctxToUse.rect(centerX - armWidth / 2, centerY - armHeight / 2, armWidth, armHeight);
            // Horizontal arm
            ctxToUse.rect(centerX - armHeight / 2, centerY - armWidth / 2, armHeight, armWidth);
            ctxToUse.closePath();
        }

        /**
         * Draws a diamond shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} centerX - The x-coordinate of the center.
         * @param {number} centerY - The y-coordinate of the center.
         * @param {number} width - The total width of the diamond.
         * @param {number} height - The total height of the diamond.
         */
        function drawDiamond(ctxToUse, centerX, centerY, width, height) {
            ctxToUse.beginPath();
            ctxToUse.moveTo(centerX, centerY - height / 2); // Top
            ctxToUse.lineTo(centerX + width / 2, centerY);     // Right
            ctxToUse.lineTo(centerX, centerY + height / 2); // Bottom
            ctxToUse.lineTo(centerX - width / 2, centerY);     // Left
            ctxToUse.closePath();
        }

        /**
         * Draws a speech bubble shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} sx - Starting x-coordinate for the main body.
         * @param {number} sy - Starting y-coordinate for the main body.
         * @param {number} ex - Ending x-coordinate for the main body.
         * @param {number} ey - Ending y-coordinate for the main body.
         */
        function drawSpeechBubble(ctxToUse, sx, sy, ex, ey) {
            const width = Math.abs(ex - sx);
            const height = Math.abs(ey - sy);
            const x = Math.min(sx, ex);
            const y = Math.min(sy, ey);

            const borderRadius = Math.min(width, height) * 0.15;
            const pointerBaseWidth = width * 0.1;
            const pointerLength = height * 0.2;

            ctxToUse.beginPath();
            ctxToUse.moveTo(x + borderRadius, y);
            ctxToUse.lineTo(x + width - borderRadius, y);
            ctxToUse.quadraticCurveTo(x + width, y, x + width, y + borderRadius);
            ctxToUse.lineTo(x + width, y + height - borderRadius);
            ctxToUse.quadraticCurveTo(x + width, y + height, x + width - borderRadius, y + height);
            
            // Pointer (bottom center)
            const pointerTipX = x + width / 2;
            const pointerTipY = y + height + pointerLength;
            ctxToUse.lineTo(pointerTipX + pointerBaseWidth / 2, y + height);
            ctxToUse.lineTo(pointerTipX, pointerTipY);
            ctxToUse.lineTo(pointerTipX - pointerBaseWidth / 2, y + height);

            ctxToUse.lineTo(x + borderRadius, y + height);
            ctxToUse.quadraticCurveTo(x, y + height, x, y + height - borderRadius);
            ctxToUse.lineTo(x, y + borderRadius);
            ctxToUse.quadraticCurveTo(x, y, x + borderRadius, y);
            ctxToUse.closePath();
        }

        /**
         * Draws a trapezoid shape.
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {number} sx - Starting x-coordinate.
         * @param {number} sy - Starting y-coordinate.
         * @param {number} ex - Ending x-coordinate.
         * @param {number} ey - Ending y-coordinate.
         */
        function drawTrapezoid(ctxToUse, sx, sy, ex, ey) {
            const width = Math.abs(ex - sx);
            const height = Math.abs(ey - sy);
            const x = Math.min(sx, ex);
            const y = Math.min(sy, ey);
            
            const topWidthRatio = 0.6; // Top width is 60% of base width
            const topOffset = (width * (1 - topWidthRatio)) / 2;

            if (ey > sy) { // Drawing downwards (base at bottom)
                ctxToUse.moveTo(x + topOffset, y);              // Top-left
                ctxToUse.lineTo(x + width - topOffset, y);      // Top-right
                ctxToUse.lineTo(x + width, y + height);         // Bottom-right
                ctxToUse.lineTo(x, y + height);                 // Bottom-left
            } else { // Drawing upwards (base at top)
                ctxToUse.moveTo(x, y);                          // Top-left
                ctxToUse.lineTo(x + width, y);                  // Top-right
                ctxToUse.lineTo(x + width - topOffset, y - height);  // Bottom-right
                ctxToUse.lineTo(x + topOffset, y - height);          // Bottom-left
            }
            ctxToUse.closePath();
        }

        /**
         * Consolidated function to draw any supported shape.
         * Handles both temporary previews (isFinal=false) and final rendering (isFinal=true).
         * @param {CanvasRenderingContext2D} ctxToUse - The context to draw on.
         * @param {string} tool - The name of the shape tool.
         * @param {number} sx - Starting x-coordinate.
         * @param {number} sy - Starting y-coordinate.
         * @param {number} currentX - Current (or final) x-coordinate.
         * @param {number} currentY - Current (or final) y-coordinate.
         * @param {boolean} isFinal - True if drawing the final shape, false for preview.
         */
        function drawShape(ctxToUse, tool, sx, sy, currentX, currentY, isFinal = false) {
            ctxToUse.beginPath();
            let radius, radiusX, radiusY, size;
            const centerX = (sx + currentX) / 2;
            const centerY = (sy + currentY) / 2;
            const width = Math.abs(currentX - sx);
            const height = Math.abs(currentY - sy);

            switch (tool) {
                case 'rectangle':
                    ctxToUse.rect(sx, sy, currentX - sx, currentY - sy);
                    break;
                case 'square':
                    size = Math.max(Math.abs(currentX - sx), Math.abs(currentY - sy));
                    const signX = currentX > sx ? 1 : -1;
                    const signY = currentY > sy ? 1 : -1;
                    ctxToUse.rect(sx, sy, size * signX, size * signY);
                    break;
                case 'line':
                    ctxToUse.moveTo(sx, sy);
                    ctxToUse.lineTo(currentX, currentY);
                    break;
                case 'triangle':
                    const baseWidth = currentX - sx;
                    const triHeight = Math.abs(currentY - sy);
                    const tipX = sx + baseWidth / 2;
                    const tipY = currentY > sy ? sy - triHeight : sy + triHeight;

                    ctxToUse.moveTo(sx, sy);
                    ctxToUse.lineTo(currentX, sy);
                    ctxToUse.lineTo(tipX, tipY);
                    ctxToUse.closePath();
                    break;
                case 'circle':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    ctxToUse.arc(sx, sy, radius, 0, 2 * Math.PI);
                    break;
                case 'ellipse':
                    radiusX = Math.abs(currentX - sx);
                    radiusY = Math.abs(currentY - sy);
                    ctxToUse.ellipse(sx, sy, radiusX, radiusY, 0, 0, 2 * Math.PI);
                    break;
                case 'pentagon':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    drawRegularPolygon(ctxToUse, sx, sy, radius, 5);
                    break;
                case 'star':
                    const outerRadius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    const innerRadius = outerRadius * 0.4; 
                    drawStar(ctxToUse, sx, sy, outerRadius, innerRadius, 5);
                    break;
                case 'hexagon':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    drawRegularPolygon(ctxToUse, sx, sy, radius, 6);
                    break;
                case 'heptagon':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    drawRegularPolygon(ctxToUse, sx, sy, radius, 7);
                    break;
                case 'octagon':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    drawRegularPolygon(ctxToUse, sx, sy, radius, 8);
                    break;
                case 'nonagon':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    drawRegularPolygon(ctxToUse, sx, sy, radius, 9);
                    break;
                case 'decagon':
                    radius = Math.sqrt(Math.pow(currentX - sx, 2) + Math.pow(currentY - sy, 2));
                    drawRegularPolygon(ctxToUse, sx, sy, radius, 10);
                    break;
                case 'heart':
                    drawHeart(ctxToUse, centerX, centerY, Math.max(width, height));
                    break;
                case 'arrow':
                    drawArrow(ctxToUse, sx, sy, currentX, currentY);
                    break;
                case 'cloud':
                    drawCloud(ctxToUse, centerX, centerY, Math.max(width, height));
                    break;
                case 'lightning':
                    drawLightning(ctxToUse, sx, sy, currentX, currentY);
                    break;
                case 'cross':
                    drawCross(ctxToUse, centerX, centerY, Math.max(width, height));
                    break;
                case 'diamond':
                    drawDiamond(ctxToUse, centerX, centerY, width, height);
                    break;
                case 'speechBubble':
                    drawSpeechBubble(ctxToUse, sx, sy, currentX, currentY);
                    break;
                case 'trapezoid':
                    drawTrapezoid(ctxToUse, sx, sy, currentX, currentY);
                    break;
            }

            // Apply stroke
            ctxToUse.strokeStyle = currentColor;
            if (isFinal) {
                applyDrawingSettings(ctxToUse); // Reapply settings for final draw
            }

            // Apply fill for non-line-based shapes
            if (tool !== 'line' && tool !== 'arrow' && tool !== 'lightning') { 
                if (currentFillType === 'solidColor') {
                    ctxToUse.fillStyle = currentColor;
                } else if (currentFillType === 'linearGradient') {
                    const gradient = ctxToUse.createLinearGradient(sx, sy, currentX, currentY);
                    gradient.addColorStop(0, currentColor);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)'); 
                    ctxToUse.fillStyle = gradient;
                }
                ctxToUse.fill();
            }
            ctxToUse.stroke();
        }


        // --- Drawing Event Handlers ---
        /**
         * Handles the start of a drawing operation (mousedown/touchstart).
         * Takes a snapshot of the canvas for shape previews.
         * @param {MouseEvent|TouchEvent} e - The mouse or touch event.
         */
        function startDrawing(e) {
            e.preventDefault(); // Prevent default touch behavior (scrolling, zooming)
            isDrawing = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = canvas.getBoundingClientRect();
            startX = clientX - rect.left;
            startY = clientY - rect.top;

            // Take a snapshot of the *entire* canvas state *before* this drawing action starts.
            snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height); 
            // console.log('startDrawing: Snapshot taken.');

            applyDrawingSettings(); // Apply current tool settings

            const toolsThatDrawContinuously = ['pen', 'eraser'];

            if (toolsThatDrawContinuously.includes(currentTool)) {
                ctx.beginPath(); // Start a new path for pen/eraser
                ctx.moveTo(startX, startY); // Move to the initial click point
            } else if (currentTool === 'fill') {
                // Fill tool is a one-shot operation
                isDrawing = false; // Set to false immediately after fill
                fillColor(startX, startY); // Call fill, which handles its own state saving
            } else if (currentTool === 'text') {
                // Position and show the text input overlay
                textInputOverlay.style.left = `${clientX}px`;
                textInputOverlay.style.top = `${clientY}px`;
                textInputOverlay.style.display = 'block';
                textInputOverlay.focus();
            }
        }

        /**
         * Handles drawing during a mouse movement (mousemove/touchmove).
         * Provides live previews for shapes/images by continually restoring the snapshot
         * and redrawing the current shape.
         * @param {MouseEvent|TouchEvent} e - The mouse or touch event.
         */
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault(); // Prevent default touch behavior (scrolling, zooming)

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            ctx.globalCompositeOperation = 'source-over'; // Default for most tools

            const toolsThatUseSnapshotForPreview = ['line', 'rectangle', 'square', 'triangle', 'circle', 'ellipse', 'pentagon', 'star', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'heart', 'arrow', 'cloud', 'lightning', 'cross', 'diamond', 'speechBubble', 'trapezoid', 'image'];

            // Tools that draw continuously (pen, eraser)
            if (currentTool === 'pen') {
                applyDrawingSettings();
                ctx.strokeStyle = currentColor;
                
                // Draw primary stroke segment
                ctx.lineTo(x, y);
                ctx.stroke();

                // Apply symmetry for pen (draw mirrored strokes)
                if (hSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
                    ctx.lineTo(canvas.width - x, y); ctx.stroke(); ctx.restore();
                }
                if (vSymmetryEnabled) {
                    ctx.save(); ctx.translate(0, canvas.height); ctx.scale(1, -1);
                    ctx.lineTo(x, canvas.height - y); ctx.stroke(); ctx.restore();
                }
                if (hSymmetryEnabled && vSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, canvas.height); ctx.scale(-1, -1);
                    ctx.lineTo(canvas.width - x, canvas.height - y); ctx.stroke(); ctx.restore();
                }
                ctx.moveTo(x, y); // Continue path from current point

            } else if (currentTool === 'eraser') {
                applyDrawingSettings();
                ctx.strokeStyle = getComputedStyle(canvas).backgroundColor; // Eraser uses background color to simulate erasing
                ctx.globalCompositeOperation = 'destination-out'; // Makes pixels transparent
                
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Apply symmetry to eraser (draw mirrored erase strokes)
                if (hSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
                    ctx.lineTo(canvas.width - x, y); ctx.stroke(); ctx.restore();
                }
                if (vSymmetryEnabled) {
                    ctx.save(); ctx.translate(0, canvas.height); ctx.scale(1, -1);
                    ctx.lineTo(x, canvas.height - y); ctx.stroke(); ctx.restore();
                }
                if (hSymmetryEnabled && vSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, canvas.height); ctx.scale(-1, -1);
                    ctx.lineTo(canvas.width - x, canvas.height - y); ctx.stroke(); ctx.restore();
                }
                ctx.moveTo(x, y); // Continue path from current point
            }
            // Tools that use snapshot for live preview (shapes, image)
            else if (toolsThatUseSnapshotForPreview.includes(currentTool)) {
                // Restore canvas to the state captured at startDrawing (before this preview drag).
                ctx.putImageData(snapshot, 0, 0); 
                // console.log('draw: Restored snapshot for preview.');

                applyDrawingSettings(); // Reapply current settings (important for opacity etc.)

                // Draw primary shape preview
                if (currentTool !== 'image') {
                    drawShape(ctx, currentTool, startX, startY, x, y, false); // false for preview
                } else if (loadedImage) {
                    const imgWidth = loadedImage.width * 0.5;
                    const imgHeight = loadedImage.height * 0.5;
                    ctx.drawImage(loadedImage, x - imgWidth / 2, y - imgHeight / 2, imgWidth, imgHeight);
                }

                // Draw symmetrical shapes for preview (on top of the restored snapshot)
                if (hSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
                    if (currentTool !== 'image') {
                        drawShape(ctx, currentTool, canvas.width - startX, startY, canvas.width - x, y, false);
                    } else if (loadedImage) {
                        const imgWidth = loadedImage.width * 0.5;
                        const imgHeight = loadedImage.height * 0.5;
                        ctx.drawImage(loadedImage, canvas.width - (x - imgWidth / 2) - imgWidth, y - imgHeight / 2, imgWidth, imgHeight);
                    }
                    ctx.restore();
                }
                if (vSymmetryEnabled) {
                    ctx.save(); ctx.translate(0, canvas.height); ctx.scale(1, -1);
                    if (currentTool !== 'image') {
                        drawShape(ctx, currentTool, startX, canvas.height - startY, x, canvas.height - y, false);
                    } else if (loadedImage) {
                         const imgWidth = loadedImage.width * 0.5;
                         const imgHeight = loadedImage.height * 0.5;
                         ctx.drawImage(loadedImage, x - imgWidth / 2, canvas.height - (y - imgHeight / 2) - imgHeight, imgWidth, imgHeight);
                    }
                    ctx.restore();
                }
                if (hSymmetryEnabled && vSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, canvas.height); ctx.scale(-1, -1);
                    if (currentTool !== 'image') {
                        drawShape(ctx, currentTool, canvas.width - startX, canvas.height - startY, canvas.width - x, canvas.height - y, false);
                    } else if (loadedImage) {
                         const imgWidth = loadedImage.width * 0.5;
                         const imgHeight = loadedImage.height * 0.5;
                         ctx.drawImage(loadedImage, canvas.width - (x - imgWidth / 2) - imgWidth, canvas.height - (y - imgHeight / 2) - imgHeight, imgWidth, imgHeight);
                    }
                    ctx.restore();
                }
            }
        }

        /**
         * Handles the end of a drawing operation (mouseup/touchend/touchcancel).
         * Finalizes shapes/images by redrawing them permanently and saves the new canvas state to history.
         * @param {MouseEvent|TouchEvent} e - The mouse or touch event.
         */
        function stopDrawing(e) {
            if (!isDrawing) return; // If not drawing, do nothing.

            isDrawing = false; // Stop the drawing flag
            ctx.globalAlpha = 1; // Reset alpha after a drawing operation is complete
            ctx.globalCompositeOperation = 'source-over'; // Ensure we draw normally for final render

            const toolsThatUseSnapshotForPreview = ['line', 'rectangle', 'square', 'triangle', 'circle', 'ellipse', 'pentagon', 'star', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'heart', 'arrow', 'cloud', 'lightning', 'cross', 'diamond', 'speechBubble', 'trapezoid', 'image'];

            if (toolsThatUseSnapshotForPreview.includes(currentTool)) {
                // IMPORTANT FIX: Restore the canvas to the state *before* this specific drawing action began.
                // This effectively clears the temporary preview of the current shape.
                ctx.putImageData(snapshot, 0, 0);
                // console.log('stopDrawing (shape): Restored snapshot, preparing final draw.');
                
                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

                const rect = canvas.getBoundingClientRect();
                const finalX = clientX - rect.left;
                const finalY = clientY - rect.top;

                applyDrawingSettings(); // Apply current settings (including opacity) for the final draw

                // Draw primary shape for final permanent rendering
                if (currentTool !== 'image') {
                    drawShape(ctx, currentTool, startX, startY, finalX, finalY, true); // true for final render
                } else if (loadedImage) {
                    // For image, draw it once at the final position
                    const imgWidth = loadedImage.width * 0.5; 
                    const imgHeight = loadedImage.height * 0.5;
                    ctx.drawImage(loadedImage, finalX - imgWidth / 2, finalY - imgHeight / 2, imgWidth, imgHeight);
                }

                // Draw symmetrical shapes for final permanent rendering
                if (hSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
                    if (currentTool !== 'image') {
                        drawShape(ctx, currentTool, canvas.width - startX, startY, canvas.width - finalX, finalY, true);
                    } else if (loadedImage) {
                         const imgWidth = loadedImage.width * 0.5;
                         const imgHeight = loadedImage.height * 0.5;
                         ctx.drawImage(loadedImage, canvas.width - (finalX - imgWidth / 2) - imgWidth, finalY - imgHeight / 2, imgWidth, imgHeight);
                    }
                    ctx.restore();
                }
                if (vSymmetryEnabled) {
                    ctx.save(); ctx.translate(0, canvas.height); ctx.scale(1, -1);
                    if (currentTool !== 'image') {
                        drawShape(ctx, currentTool, startX, canvas.height - startY, finalX, canvas.height - finalY, true);
                    } else if (loadedImage) {
                         const imgWidth = loadedImage.width * 0.5;
                         const imgHeight = loadedImage.height * 0.5;
                         ctx.drawImage(loadedImage, finalX - imgWidth / 2, canvas.height - (finalY - imgHeight / 2) - imgHeight, imgWidth, imgHeight);
                    }
                    ctx.restore();
                }
                if (hSymmetryEnabled && vSymmetryEnabled) {
                    ctx.save(); ctx.translate(canvas.width, canvas.height); ctx.scale(-1, -1);
                    if (currentTool !== 'image') {
                        drawShape(ctx, currentTool, canvas.width - startX, canvas.height - startY, canvas.width - finalX, canvas.height - finalY, true);
                    } else if (loadedImage) {
                         const imgWidth = loadedImage.width * 0.5;
                         const imgHeight = loadedImage.height * 0.5;
                         ctx.drawImage(loadedImage, canvas.width - (finalX - imgWidth / 2) - imgWidth, canvas.height - (finalY - imgHeight / 2) - imgHeight, imgWidth, imgHeight);
                    }
                    ctx.restore();
                }

                loadedImage = null; // Clear loaded image data after final placement
                saveState(); // Save the new, updated canvas state to history
            } else if (currentTool === 'pen' || currentTool === 'eraser') {
                // For pen/eraser, drawing is continuous, so just save the state after the stroke ends.
                ctx.beginPath(); // Ensure path is reset for next stroke
                saveState();
                // console.log('stopDrawing (pen/eraser): State saved.');
            }
        }

        // --- Fill Tool Logic (Flood Fill Algorithm) ---
        /**
         * Converts a hexadecimal color string to an RGB array.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {number[]} An array [R, G, B].
         */
        function hexToRgb(hex) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return [r, g, b];
        }

        /**
         * Compares two color arrays (including alpha if present).
         * @param {number[]} color1 - The first color array.
         * @param {number[]} color2 - The second color array.
         * @returns {boolean} True if the colors are identical, false otherwise.
         */
        function compareColors(color1, color2) {
            if (!color1 || !color2 || color1.length < 3 || color2.length < 3) return false;
            return color1[0] === color2[0] &&
                   color1[1] === color2[1] &&
                   color1[2] === color2[2] &&
                   (color1.length === 4 && color2.length === 4 ? color1[3] === color2[3] : true);
        }

        /**
         * Gets the RGBA color value of a pixel at specified coordinates from ImageData.
         * @param {number} x - The x-coordinate of the pixel.
         * @param {number} y - The y-coordinate of the pixel.
         * @param {ImageData} imageData - The ImageData object to read from.
         * @returns {number[]} An array [R, G, B, A].
         */
        function getColorAtPixel(x, y, imageData) {
            const pixelPos = (y * canvas.width + x) * 4;
            return [
                imageData.data[pixelPos],
                imageData.data[pixelPos + 1],
                imageData.data[pixelPos + 2],
                imageData.data[pixelPos + 3] // Include alpha
            ];
        }

        /**
         * Fills an enclosed area with the current color using a flood fill algorithm.
         * @param {number} startX - The starting x-coordinate for the fill.
         * @param {number} startY - The starting y-coordinate for the fill.
         */
        function fillColor(startX, startY) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const targetColor = getColorAtPixel(startX, startY, imageData);

            let fillColorStyle;
            if (currentFillType === 'solidColor' || currentFillType === 'linearGradient') {
                // For simplicity, flood fill currently uses solid color even if gradient is selected.
                const rgb = hexToRgb(currentColor);
                fillColorStyle = [rgb[0], rgb[1], rgb[2], Math.round(currentOpacity * 255)];
            }

            if (!fillColorStyle) return; // Exit if fill style couldn't be determined

            if (compareColors(targetColor, fillColorStyle)) {
                return; // Target color is already the fill color, no operation needed
            }

            const stack = [[startX, startY]];
            const visited = new Set(); // To avoid infinite loops and re-processing pixels

            // Helper to generate a unique key for a pixel (x,y)
            function getPixelKey(x, y) {
                return `${x},${y}`;
            }

            // Perform flood fill using a stack-based approach
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const pixelPos = (y * canvas.width + x) * 4;

                // Check bounds and if already visited or doesn't match target color
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height ||
                    !compareColors(getColorAtPixel(x, y, imageData), targetColor) ||
                    visited.has(getPixelKey(x, y))) {
                    continue; // Skip this pixel
                }

                // Set pixel color
                data[pixelPos] = fillColorStyle[0];
                data[pixelPos + 1] = fillColorStyle[1];
                data[pixelPos + 2] = fillColorStyle[2];
                data[pixelPos + 3] = fillColorStyle[3]; // Alpha

                visited.add(getPixelKey(x, y)); // Mark as visited

                // Add neighbors to stack
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
            ctx.putImageData(imageData, 0, 0); // Apply the modified image data back to the canvas
            saveState(); // Save state after flood fill
        }


        // --- Event Listeners ---
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing); // Stop drawing if mouse leaves canvas

        canvas.addEventListener('touchstart', startDrawing, { passive: false }); // passive: false to allow preventDefault
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing); // For when touch is interrupted


        penToolBtn.addEventListener('click', () => selectTool('pen'));
        eraserToolBtn.addEventListener('click', () => selectTool('eraser'));
        fillToolBtn.addEventListener('click', () => selectTool('fill'));
        textToolBtn.addEventListener('click', () => selectTool('text'));

        // Shape Selector Listener
        shapeToolSelector.addEventListener('change', (e) => {
            selectTool(e.target.value);
        });


        insertImageToolBtn.addEventListener('click', () => {
            imageInput.click();
        });

        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedImage = img; // This is for drawable images
                        selectTool('image');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            imageInput.value = ''; // Clear file input
        });

        textInputOverlay.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = textInputOverlay.value.trim();
                if (text) {
                    const rect = canvas.getBoundingClientRect();
                    // Positioning the text relative to the canvas, accounting for potential scrolling
                    const canvasX = parseFloat(textInputOverlay.style.left) - rect.left + window.scrollX;
                    const canvasY = parseFloat(textInputOverlay.style.top) - rect.top + textInputOverlay.offsetHeight + window.scrollY;

                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = currentOpacity; // Apply opacity for text
                    ctx.fillStyle = currentColor; // Text uses solid color for simplicity
                    ctx.font = `${currentBrushSize * 2}px Arial`;
                    ctx.fillText(text, canvasX, canvasY);
                    ctx.globalAlpha = 1; // Reset after drawing
                    saveState();
                }
                textInputOverlay.value = '';
                textInputOverlay.style.display = 'none';
                selectTool('pen');
            } else if (e.key === 'Escape') {
                textInputOverlay.value = '';
                textInputOverlay.style.display = 'none';
                selectTool('pen');
            }
        });

        // Hide text input if clicking outside of it or canvas/toolbar elements
        document.addEventListener('mousedown', (e) => {
            const isClickInsideToolbar = Array.from(document.querySelectorAll('.toolbar button, .toolbar input, .toolbar select')).some(el => el.contains(e.target));
            // Check if click is outside the text input and not on the text tool button itself
            if (currentTool === 'text' && textInputOverlay.style.display === 'block' &&
                !textInputOverlay.contains(e.target) && !canvas.contains(e.target) &&
                e.target !== textToolBtn && e.target !== darkModeToggle && !isClickInsideToolbar
            ) {
                const text = textInputOverlay.value.trim();
                if (text) {
                    const rect = canvas.getBoundingClientRect();
                    const canvasX = parseFloat(textInputOverlay.style.left) - rect.left + window.scrollX;
                    const canvasY = parseFloat(textInputOverlay.style.top) - rect.top + textInputOverlay.offsetHeight + window.scrollY;

                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = currentOpacity; // Apply opacity for text
                    ctx.fillStyle = currentColor; // Text uses solid color for simplicity
                    ctx.font = `${currentBrushSize * 2}px Arial`;
                    ctx.fillText(text, canvasX, canvasY);
                    ctx.globalAlpha = 1; // Reset after drawing
                    saveState();
                }
                textInputOverlay.value = '';
                textInputOverlay.style.display = 'none';
                selectTool('pen');
            }
        });


        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            updateBrushPreview();
        });

        brushSizeSlider.addEventListener('input', (e) => {
            currentBrushSize = parseInt(e.target.value);
            brushSizeValueSpan.textContent = currentBrushSize;
            updateBrushPreview();
        });

        opacitySlider.addEventListener('input', (e) => {
            currentOpacity = parseFloat(e.target.value) / 100;
            opacityValueSpan.textContent = e.target.value;
            updateBrushPreview();
        });

        lineStyleSelector.addEventListener('change', (e) => {
            currentLineStyle = e.target.value;
            applyDrawingSettings(); // Reapply to update line dash
        });

        fillTypeSelector.addEventListener('change', (e) => {
            currentFillType = e.target.value;
        });

        // Symmetry Tool Listeners
        hSymmetryToolBtn.addEventListener('click', () => {
            hSymmetryEnabled = !hSymmetryEnabled;
            hSymmetryToolBtn.classList.toggle('active', hSymmetryEnabled);
        });
        vSymmetryToolBtn.addEventListener('click', () => {
            vSymmetryEnabled = !vSymmetryEnabled;
            vSymmetryToolBtn.classList.toggle('active', vSymmetryEnabled);
        });

        // Background Type Selector Listener
        backgroundTypeSelector.addEventListener('change', (e) => {
            currentBackgroundType = e.target.value;
            if (currentBackgroundType !== 'image') { // Clear image if not selecting image type
                loadedBackgroundImage = null;
            }
            restoreState(); // Redraw background and then existing drawing
        });

        // Set Background Image Listener
        setBackgroundImageBtn.addEventListener('click', () => {
            backgroundImageInput.click();
        });

        backgroundImageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedBackgroundImage = img;
                        currentBackgroundType = 'image';
                        backgroundTypeSelector.value = 'image'; // Update dropdown
                        restoreState(); // Redraw background with the new image
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            backgroundImageInput.value = ''; // Clear file input
        });

        // --- Guided Drawing Mode Listeners ---
        guidedDrawingBtn.addEventListener('click', () => {
            guidedImageInput.click();
        });

        guidedImageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        guidedImage = img;
                        guidedOptions.style.display = 'flex'; // Show guide options
                        restoreState(); // Redraw canvas with the guide
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            guidedImageInput.value = ''; // Clear file input
        });

        guidedImageOpacitySlider.addEventListener('input', (e) => {
            guidedImageOpacity = parseFloat(e.target.value) / 100;
            guidedImageOpacityValueSpan.textContent = e.target.value;
            restoreState(); // Redraw canvas to update guide opacity
        });

        clearGuideBtn.addEventListener('click', () => {
            guidedImage = null;
            guidedOptions.style.display = 'none'; // Hide guide options
            restoreState(); // Redraw canvas without the guide
        });

        // --- Drawing Challenges ---
        /**
         * Formats seconds into a MM:SS string.
         * @param {number} seconds - The number of seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        /**
         * Updates the challenge timer display and handles challenge end.
         */
        function updateChallengeTimer() {
            challengeTimeLeft--;
            challengeTimerDisplay.textContent = formatTime(challengeTimeLeft);

            if (challengeTimeLeft <= 0) {
                clearInterval(challengeInterval);
                challengeTimerDisplay.textContent = "Time's Up!";
                // Optionally, save the drawing or display a "challenge complete" message
                setTimeout(() => {
                    challengeContainer.style.display = 'none';
                    challengePromptDisplay.textContent = ''; // Clear prompt
                }, 3000); // Hide after 3 seconds
            }
        }

        /**
         * Starts a new drawing challenge with a random prompt and timer.
         */
        startChallengeBtn.addEventListener('click', () => {
            clearInterval(challengeInterval); // Clear any existing challenge
            clearCanvasBtn.click(); // Clear canvas for a fresh start

            const randomIndex = Math.floor(Math.random() * drawingPrompts.length);
            const prompt = drawingPrompts[randomIndex];
            challengePromptDisplay.textContent = prompt;

            challengeTimeLeft = 120; // 2 minutes
            challengeTimerDisplay.textContent = formatTime(challengeTimeLeft);

            challengeContainer.style.display = 'block';
            challengeInterval = setInterval(updateChallengeTimer, 1000);
        });


        undoBtn.addEventListener('click', () => {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState();
            }
        });

        /**
         * Clears the entire canvas, resets history, and draws the current background.
         */
        clearCanvasBtn.addEventListener('click', () => {
            history.length = 0; // Clear history
            historyIndex = -1;
            drawBackground(); // Just draw the current background
            drawGuidedImage(); // Re-draw guided image if it exists
            saveState(); // Save the cleared state to history
            selectTool('pen'); // Default to pen tool after clearing
        });

        /**
         * Saves the current canvas content as a PNG image.
         */
        saveDrawingBtn.addEventListener('click', () => {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'my_drawing.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        /**
         * Toggles dark mode on/off and updates the UI.
         */
        darkModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            // Re-apply background after dark mode toggle, then restore drawing history
            restoreState(); 

            if (document.body.classList.contains('dark-mode')) {
                localStorage.setItem('darkMode', 'enabled');
                darkModeToggle.textContent = '☀️ Light Mode';
            } else {
                localStorage.setItem('darkMode', 'disabled');
                darkModeToggle.textContent = '🌓 Dark Mode';
            }
            // Update eraser color and brush preview to reflect new background
            if (currentTool === 'eraser') {
                ctx.strokeStyle = getComputedStyle(canvas).backgroundColor;
            }
            updateBrushPreview();
        });

        // --- Canvas Size Management ---
        /**
         * Resizes the canvas to the specified width and height, preserving existing content.
         */
        applyCanvasSizeBtn.addEventListener('click', () => {
            const newWidth = parseInt(canvasWidthInput.value);
            const newHeight = parseInt(canvasHeightInput.value);

            if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 100 || newHeight < 200 || newWidth > 2000 || newHeight > 2000) {
                // Using a custom message box instead of alert as per instructions
                const msg = document.createElement('div');
                msg.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: var(--container-bg); border: 2px solid var(--border-color);
                    padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                    z-index: 9999; text-align: center; color: var(--text-color);
                `;
                msg.innerHTML = `
                    <p style="margin-bottom: 15px; font-weight: bold;">Please enter valid width and height between 100 and 2000 pixels.</p>
                    <button style="padding: 8px 15px; background-color: var(--button-bg); color: white; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                `;
                document.body.appendChild(msg);
                msg.querySelector('button').onclick = () => msg.remove();
                return;
            }

            // Save the current canvas content as a DataURL before resizing
            // This captures everything *currently* on the canvas, including background.
            const oldCanvasData = canvas.toDataURL();
            const oldCanvasWidth = canvas.width;
            const oldCanvasHeight = canvas.height;

            // Update canvas dimensions (this action itself clears the canvas and resets its state)
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Immediately redraw the current background based on the new dimensions/theme
            drawBackground();

            // Load the old canvas data back and draw it, scaled to new dimensions
            const oldImg = new Image();
            oldImg.src = oldCanvasData;
            oldImg.onload = () => {
                // To scale correctly, we draw the old image relative to its old size to the new size
                // This will scale *everything* on the old canvas, including its potentially old background.
                // As explained in the problem description, this means if you change theme AFTER drawing,
                // the old drawings will retain their original background color.
                ctx.drawImage(oldImg, 0, 0, oldCanvasWidth, oldCanvasHeight, 0, 0, newWidth, newHeight);
                drawGuidedImage(); // Draw guided image on top of the scaled drawing
                saveState(); // Save this new resized state to history
            };
            oldImg.onerror = (e) => {
                console.error("Error loading old canvas data for resize:", e);
                // Fallback: If old image fails to load, at least save the new empty state
                drawGuidedImage(); // Draw guided image
                saveState();
            };
        });


        // --- Keyboard Shortcuts ---
        /**
         * Handles keyboard shortcuts for tools and actions.
         * @param {KeyboardEvent} e - The keyboard event.
         */
        document.addEventListener('keydown', (e) => {
            // Prevent shortcuts if typing in the text input or challenge is active
            if (textInputOverlay.style.display === 'block' || challengeContainer.style.display === 'block') {
                return; 
            }

            if (e.ctrlKey || e.metaKey) { // For Ctrl (Windows/Linux) or Cmd (Mac)
                if (e.key.toLowerCase() === 'z') {
                    e.preventDefault(); // Prevent browser undo
                    undoBtn.click();
                } else if (e.key.toLowerCase() === 'y') {
                    e.preventDefault(); // Prevent browser redo
                    redoBtn.click();
                } else if (e.key.toLowerCase() === 'h') { // Ctrl+H for Heart
                    e.preventDefault(); 
                    shapeToolSelector.value = 'heart';
                    selectTool('heart');
                }
            } else {
                switch (e.key.toLowerCase()) {
                    case 'p': selectTool('pen'); break; // Pen
                    case 'e': selectTool('eraser'); break; // Eraser
                    case 'f': selectTool('fill'); break; // Fill
                    case 't': // Text or Triangle 
                        if (currentTool === 'text') {
                             // Do nothing, let text input handle it (though blocked by initial check)
                        } else {
                            shapeToolSelector.value = 'triangle';
                            selectTool('triangle');
                        }
                        break;
                    case 'r': // Rectangle
                        shapeToolSelector.value = 'rectangle';
                        selectTool('rectangle');
                        break;
                    case 'c': // Circle
                        shapeToolSelector.value = 'circle';
                        selectTool('circle');
                        break;
                    case 's': // Star
                        shapeToolSelector.value = 'star';
                        selectTool('star');
                        break;
                    case 'h': // Hexagon (single key)
                        shapeToolSelector.value = 'hexagon';
                        selectTool('hexagon');
                        break;
                    case '7': // Heptagon
                        shapeToolSelector.value = 'heptagon';
                        selectTool('heptagon');
                        break;
                    case '8': // Octagon
                        selectTool('octagon');
                        break;
                    case '9': // Nonagon
                        selectTool('nonagon');
                        break;
                    case '0': // Decagon
                        selectTool('decagon');
                        break;
                    case 'a': // Arrow
                        selectTool('arrow');
                        break;
                    case 'l': // Cloud (cLoud)
                        selectTool('cloud');
                        break;
                    case 'i': // Lightning (lIghtning)
                        selectTool('lightning');
                        break;
                    case 'x': // Cross
                        selectTool('cross');
                        break;
                    case 'd': // Diamond
                        selectTool('diamond');
                        break;
                    case 'b': // Speech Bubble
                        selectTool('speechBubble');
                        break;
                    case 'z': // Trapezoid
                        selectTool('trapezoid');
                        break;
                    case 'delete': // For 'Delete' key
                    case 'backspace': // For 'Backspace' key, often also mapped to clear
                        clearCanvasBtn.click();
                        break;
                }
            }
        });


        // Check for saved dark mode preference on load
        if (localStorage.getItem('darkMode') === 'enabled') {
            document.body.classList.add('dark-mode');
            darkModeToggle.textContent = '☀️ Light Mode';
        } else {
            darkModeToggle.textContent = '🌓 Dark Mode';
        }


        // Initial setup on page load
        selectTool('pen'); // Set initial tool to pen
        
        // Attempt to load from local storage first
        if (!loadFromLocalStorage()) {
            // If no saved data, then clear and save initial state (default canvas size)
            clearCanvasBtn.click(); 
        }
        
        // Initialize canvas size inputs with current canvas dimensions (might be from loaded data)
        canvasWidthInput.value = canvas.width;
        canvasHeightInput.value = canvas.height;

        updateBrushPreview(); // Initialize brush preview display
        guidedImageOpacityValueSpan.textContent = guidedImageOpacitySlider.value; // Initialize guide opacity display

        // Prevent right click context menu on the canvas
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
            .then(reg => {
            console.log('Service Worker registered:', reg.scope);
            })
            .catch(err => {
            console.log('Service Worker registration failed:', err);
            });
        });
        }   

    </script>
</body>
</html>